#
#  Eliminate all inequalities not implied by Figure 1.
#
#  Mark Bowron, 18 Nov 2019.
#

# initialize adjacency matrix adj to 34 by 34 identity matrix
adj = [[0] * 34 for _ in range(34)]
for i in range(34):
	adj[i][i] = 1

# 34 operators in KF_1
op = (
'Id','closure','interior','frontier',
'ik','fk','ki','fi','if','ff',
'kik','fik','iki','fki','kif','fif','zero',
'complement','ck','ci','cf',
'cik','cfk','cki','cfi','cif','cff',
'ckik','cfik','ciki','cfki','ckif','cfif','one'
)

# 68 arrows in Figure 1
ineqs = (
('Id','closure'),
('closure','one'),
('interior','Id'),
('interior','iki'),
('interior','cf'),
('frontier','closure'),
('frontier','ci'),
('ik','kik'),
('ik','cfk'),
('fk','ff'),
('fk','cik'),
('ki','kik'),
('ki','cif'),
('fi','ki'),
('fi','ff'),
('if','ik'),
('if','kif'),
('if','cki'),
('if','cff'),
('ff','frontier'),
('ff','cif'),
('kik','closure'),
('fik','fk'),
('fik','kik'),
('iki','ik'),
('iki','ki'),
('iki','cfki'),
('iki','ckif'),
('fki','fi'),
('fki','ciki'),
('kif','frontier'),
('kif','kik'),
('kif','ciki'),
('fif','ff'),
('fif','kif'),
('zero','interior'),
('zero','if'),
('zero','fik'),
('zero','fki'),
('zero','fif'),
('zero','ck'),
('complement','ci'),
('ck','complement'),
('ck','cf'),
('ck','ckik'),
('ci','one'),
('cf','cff'),
('cf','ckif'),
('cik','cif'),
('cik','ciki'),
('cfk','cfik'),
('cki','cfi'),
('cki','ciki'),
('cfi','cfki'),
('cif','one'),
('cff','cfk'),
('cff','cfi'),
('cff','cfif'),
('ckik','cik'),
('ckik','cki'),
('ckik','cfik'),
('ckik','ckif'),
('cfik','one'),
('ciki','ci'),
('cfki','one'),
('ckif','cif'),
('ckif','cfif'),
('cfif','one')
)

# for each arrow in Figure 1, put a 1 in adj
for arrow in ineqs:
	adj[op.index(arrow[0])][op.index(arrow[1])] = 1

def warshall(a):
	"""
	compute the transitive closure of an adjacency matrix
	using Floyd-Warshall algorithm
	"""
	assert (len(row) == len(a) for row in a)
	n = len(a)
	for k in range(n):
		for i in range(n):
			for j in range(n):
				a[i][j] = a[i][j] or (a[i][k] and a[k][j])
	return a

adj = warshall(adj)

# partition $P$ consists of:

# p[0] = (-\infty,0)
# p[1] = {0}
# p[2] = (0,1)
# p[3] = {1}
# p[4] = (1,2)
# p[5] = {2}
# p[6] = (2,3) intersect Q
# p[7] = (2,3) minus Q
# p[8] = {3}
# p[9] = (3,4)
# p[10] = {4}
# p[11] = (4,5)
# p[12] = {5}
# p[13] = (5,6)
# p[14] = {6}
# p[15] = (6,\infty)

# x represents the seed set $A$ in each of the functions below

def k(x):
	"""closure operator"""
	assert (len(x) == 16)
	p = list(x)
	"""p[0] = p[0]"""
	if p[0]+p[1]+p[2]:
		p[1] = 1
	"""p[2] = p[2]"""
	if p[2]+p[3]+p[4]:
		p[3] = 1
	"""p[4] = p[4]"""
	if p[4]+p[5]+p[6]+p[7]:
		p[5] = 1
	if p[6]+p[7]:
		p[6] = 1
		p[7] = 1
	if p[6]+p[7]+p[8]+p[9]:
		p[8] = 1
	"""p[9] = p[9]"""
	if p[9]+p[10]+p[11]:
		p[10] = 1
	"""p[11] = p[11]"""
	if p[11]+p[12]+p[13]:
		p[12] = 1
	"""p[13] = p[13]"""
	if p[13]+p[14]+p[15]:
		p[14] = 1
	"""p[15] = p[15]"""
	return p

def c(x):
	"""complement operator"""
	assert (len(x) == 16)
	p = list(x)
	for i in range(16):
		if p[i]:
			p[i] = 0
		else:
			p[i] = 1
	return p

def i(x):
	"""interior operator"""
	assert (len(x) == 16)
	p = list(x)
	p = c(p)
	p = k(p)
	p = c(p)
	return p

def intersect(x,y):
	assert (len(x) == 16 and len(y) == 16)
	p = list(x)
	q = list(y)
	for i in range(16):
		if not p[i]*q[i]:
			p[i] = 0
	return p

def f(x):
	"""frontier operator"""
	assert (len(x) == 16)
	p = list(x)
	cp = c(list(p))
	p = intersect(k(p),k(cp))
	return p

def genfam(p):
	assert (len(p) == 16)
	"""F = family generated by p under KF_1"""
	F = [[0] * 16 for _ in range(34)]

	F[op.index('Id')] = p
	F[op.index('closure')] = k(p)
	F[op.index('interior')] = i(p)
	F[op.index('frontier')] = f(p)
	F[op.index('ik')] = i(F[op.index('closure')])
	F[op.index('fk')] = f(F[op.index('closure')])
	F[op.index('ki')] = k(F[op.index('interior')])
	F[op.index('fi')] = f(F[op.index('interior')])
	F[op.index('if')] = i(F[op.index('frontier')])
	F[op.index('ff')] = f(F[op.index('frontier')])
	F[op.index('kik')] = k(F[op.index('ik')])
	F[op.index('fik')] = f(F[op.index('ik')])
	F[op.index('iki')] = i(F[op.index('ki')])
	F[op.index('fki')] = f(F[op.index('ki')])
	F[op.index('kif')] = k(F[op.index('if')])
	F[op.index('fif')] = f(F[op.index('if')])
	"""f[op.index('zero')] was already initialized to the empty set"""
	F[op.index('complement')] = c(p)
	F[op.index('ck')] = c(F[op.index('closure')])
	F[op.index('ci')] = c(F[op.index('interior')])
	F[op.index('cf')] = c(F[op.index('frontier')])
	F[op.index('cik')] = c(F[op.index('ik')])
	F[op.index('cfk')] = c(F[op.index('fk')])
	F[op.index('cki')] = c(F[op.index('ki')])
	F[op.index('cfi')] = c(F[op.index('fi')])
	F[op.index('cif')] = c(F[op.index('if')])
	F[op.index('cff')] = c(F[op.index('ff')])
	F[op.index('ckik')] = c(F[op.index('kik')])
	F[op.index('cfik')] = c(F[op.index('fik')])
	F[op.index('ciki')] = c(F[op.index('iki')])
	F[op.index('cfki')] = c(F[op.index('fki')])
	F[op.index('ckif')] = c(F[op.index('kif')])
	F[op.index('cfif')] = c(F[op.index('fif')])
	F[op.index('one')] = c(F[op.index('zero')])

	return F

def contained_in(p,q):
	assert (len(p) == 16 and len(q) == 16)
	for i in range(16):
		if p[i] and not q[i]:
			return 0
	return 1

# enter Gaida and Eremenko's seed set

p = [0] * 16
p[2] = 1;	# (0,1)
p[4] = 1;	# (1,2)
p[5] = 1;	# {2}
p[6] = 1;	# (2,3) intersect Q
p[10] = 1;	# {4}
p[12] = 1;	# {5}
p[13] = 1;	# (5,6)
p[14] = 1;	# {6}

# apply the 34 operators in KF_1 to seed set p
fam = genfam(p)

# attempt to eliminate each live inequality in adj
for j in range(34):
	for k in range(34):
		if not adj[j][k]:
			if not contained_in(fam[j],fam[k]):
				adj[j][k] = 1

# if every inequality got eliminated then every entry in adj is now 1
success = 1
for j in range(34):
	for k in range(34):
		if not adj[j][k]:
			success = 0
			break
	if not success:
		break
if success:
	print("success")
else:
	print("fail")
